from Libraries import *
from Other_funcs import *

directions = {'u': (-1,0) , 'd' : (1,0), 'l' : (0,-1), 'r' : (0,1)}

'''
@param: maze - the maze.
@param: pos - the current position of ares or stone.
@return:
    1. True: if the current position is one of the following 3 characters : '$' - stone, '#' - wall, '*' - the finished switch.
    2. False: if not.
'''
def can_stone_go(maze, pos):
    return maze[pos[0]][pos[1]] not in ['#', '$', '*']

'''
@param: maze - the maze.
@param: pos - the current position of ares or stone.
@return:
    1. True: if the current position is one of the following 3 characters : '$' - stone, '#' - wall, '*' - the finished switch.
    2. False: if not.
'''
def can_ares_go(maze, pos):
    return maze[pos[0]][pos[1]] not in ['#']

'''
@param: A list of stone positions. Such as: [ (2,2) , (3,3) ]
@param: A list of switch positions. Such as: [ (2,4) , (5,6) ]
@Return:
    1. True: All stones are placed on the switch.
    2. False: There is at least one stone not placed on the switch.
'''
def is_maze_done(stone_points, switch_points):
    return all(stone in switch_points for stone in stone_points)


'''
@param: maze: the maze.
@param: ares_init: the start position of Ares
@param: stone_points: a dictionary that contains the position of stones and its weight. For example: { (1,2) : 33, (4,5) : 66}
@param: switch_points: a list of switch positions.
@return:
    I. If we can solve the problem.
        1. path: the final path to move all the stones to switchs.
        2. node: the total of possible state generated by the algorithms.
        3. weight: the total weight of stones that are pushed by ares all the way.
    II. IF we can't find the solution.
        1. path: None.
        2. node: 0.
        3. weight: 0
'''
def solve_maze_with_bfs(maze, ares_init, stone_points, switch_points):
    init_state = (ares_init, tuple(stone_points.items()))  # tuple: stones points | weight of each stone
    initial_maze = deepcopy(maze)  # create new maze to add to state
    expanded = deque([(init_state, "", 0, initial_maze)])  # Queue: (Ares | Stone | Weight | Maze)
    visited = set()
    visited.add(init_state)
    node = 0

    while expanded:
        (ares_position, stones_with_weights), path, weight, current_maze = expanded.popleft()

        current_stone_points = dict(stones_with_weights)

        # get the successor
        if is_maze_done(current_stone_points.keys(), switch_points):
            return path, node, weight, current_maze  # return the solution

        # Ares is trying to move
        for direction, (dy, dx) in directions.items():
            ares_next = (ares_position[0] + dy, ares_position[1] + dx)

            # Can ares move?
            if can_ares_go(current_maze, ares_next) and ares_next not in current_stone_points:
                # Create a copy maze to add to new state
                new_maze = deepcopy(current_maze)
                next_state = (ares_next, tuple(current_stone_points.items()))
                new_maze[ares_next[0]][ares_next[1]] = '$'
                new_maze[ares_position[0]][ares_position[1]] = ' '
                if next_state not in visited:
                    visited.add(next_state)
                    expanded.append((next_state, path + direction, weight, new_maze))
                    node += 1
                
            # Ares found a stone -> He try to push it
            if ares_next in current_stone_points:
                new_stone_pos = (ares_next[0] + dy, ares_next[1] + dx)

                # Can ares push the stone?
                if can_stone_go(current_maze, new_stone_pos):
                    # Create new maze to add to new state
                    new_maze = deepcopy(current_maze)
                    
                    # get the stone weight
                    current_stone_weight = current_stone_points[ares_next]
                    stone_points_updated = dict(current_stone_points)

                    # update new posiotion
                    del stone_points_updated[ares_next]
                    stone_points_updated[new_stone_pos] = current_stone_weight

                    # Is the stone being a switch? Cuz ares next position is the current stone position
                    if ares_next in switch_points:
                        new_maze[ares_next[0]][ares_next[1]] = '.'  # return to '.'

                    # Stone is pushed into the switch
                    if new_stone_pos in switch_points:
                        new_maze[new_stone_pos[0]][new_stone_pos[1]] = '*'  # the switch is turned on
                    else:
                        new_maze[new_stone_pos[0]][new_stone_pos[1]] = '$'  # Update new stone position
                    
                    #Update ares position
                    new_maze[ares_next[0]][ares_next[1]] = '$'
                    new_maze[ares_position[0]][ares_position[1]] = ' '
                    
                    #Create new state
                    next_state = (ares_next, tuple(stone_points_updated.items()))

                    #Update total weight
                    total_weight = weight + current_stone_weight

                    # Check the state
                    if next_state not in visited:
                        visited.add(next_state)
                        expanded.append((next_state, path + direction.upper(), total_weight, new_maze))
                        node += 1

    return None, 0, 0, None  # No solutions found
